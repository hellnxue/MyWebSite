<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>箭头函数</title>
 
<style>

    button,[type='button']{
      background: #abcdef;  
      border: 0;
      display:  block;
      height: 3em;
      line-height: 3em;
      padding: 0 2em;
      margin-bottom: 20px;
      border-radius: .5em;
      color: #fff;
      font-size: 18px;
      box-shadow: 0 0 20px #fff; }    
          
</style>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>

<body>
<button type="button" onclick="rtnObj();">返回对象的语法</button>
<button type="button" onclick="abtArrow();">this指定是固定的</button>
<button type="button" onclick="jgArrow();">箭头函数可以与变量解构结合使用</button>
<button type="button" onclick="thisArrow();">箭头函数中的this对象</button>

<button type="button" onclick="cabArrow();">箭头函数不能用call()、apply()和bind()方法指定this</button>


<button type="button" onclick="LookThis()">普通函数中的this指向</button>

<button onclick="zmlObj">番外：对象字面量中定义的函数中的this指向</button>
 <script type="text/javascript">
    function rtnObj(){

        // 方式一
       /* var arrow=()=>{
            console.log("箭头函数");
            return {name:"helln"}
        };*/

        //方式二
        var arrow=()=>({name:"helln"});

        console.log(arrow().name);

    }


   var shut1=null,
       shut2=null;

    function Timer() {
          this.s1 = 0;
          this.s2 = 0;
          // 箭头函数
          shut1=setInterval(() => this.s1++, 1000);
          // 普通函数
          shut2=setInterval(function () {
              
            this.s2++;//当间歇函数执行时，this.s2指向的是全局中定义的变量s2
            
          }, 1000);
        }

    var s2=100;   
    var timer = new Timer();
    
    setTimeout(() => console.log('s1: ', timer.s1), 3100);//3
    setTimeout(() => console.log('timer.s2:'+timer.s2+"   "+"s2:"+s2), 3100);//0  timer.s2是不变的
    setTimeout(() => console.log('s2: ',  s2), 3100);//103

    setTimeout(() => console.log('s2: ',  s2), 5000);//103 （若不关闭间歇期，输出104，优化内存，关闭间歇器）

    //关闭间歇器
    setTimeout(()=>{
      clearInterval(shut1);
      clearInterval(shut2);
    },4000);
    
    /*
      当对象作为一个参数传入箭头函数时，函数的参数定义可以用结构赋值的语法哎
    */
     function jgArrow(){
 
        var obj={name:'helln',age:10};

        const full = ({ name, age }) => name + ' is ' + age;
        console.log(full({name:'helln',age:10}))

    }


    /*定义一个对象*/
    function testThis(){
      this.num1=1;
      this.num2=2;

      this.say=function(){
        console.log(this.num2)
      }

      this.say2=()=>{
        console.log(this.num2)
      }
    }

    /*箭头函数中的this指向是固定的,即使用方法call()也改变不了箭头函数的指向哎。。*/
    function thisArrow(){

      var tobj=new testThis();
      tobj.say();//2
      tobj.say.call({num2:101});//101
      tobj.say2();//2
      tobj.say2.call({num2:101})//2  箭头函数中的this指向是固定的，指向箭头函数定时时所在的作用域

    }


    /*关于：箭头函数中的this绑定*/
    /*点击页面，触发click事件*/
    var handler = {
        id: '123456',

        init: function() {
          document.addEventListener('click',
            event => this.doSomething(event.type), false);//此处的this指向click函数定义所在的环境，即init函数的环境（其实就是对象handler的环境）,doSomething函数是在handler环境下执行的，因此函数中的this指向的是handler对象
        },
        init2: function() {
          document.addEventListener('click',function(event){
            this.doSomething(event.type)
          },false); 
          
        },
        doSomething: function(type) {
          console.log('Handling ' + type  + ' for ' + this.id);
        }
      };

    /* 
     查看时打开多行注释即可
     handler.init();*///Handling click for 123456
      // handler.init2();//TypeError: this.doSomething is not a function


    /*由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向*/
    function cabArrow(){
      var ary=(function(){
        //此处的this指向箭头函数定义所在的作用域，即用call方法执行的函数的作用于，指向{x:'outer'}
        return [(()=>this.x).bind({x:'inner'})()];
      }).call({x:'outer'});

      var ary1=(function(){
        //普通函数中的this指向了bind函数传入的对象{x:'pinner'}
        return [((function(){return this.x}).bind({x:'pinner'}))()]
      }).call({x:'pouter'})

      console.log(ary+'');//outer

       console.log(ary1+''); //pinner
    }


var lname='hello world';
function tempFn(){
  console.log(this.lname)
}

function LookThis(){
  tempFn();//hello world
  this.lname='hello from LookThis fn';
  tempFn.call({lname:'hello obj'});
  tempFn();//hello from LookThis fn
}

function foo(){
  console.log('out:'+this.ids)//24


  setTimeout(function(){
    console.log('ids:'+this.ids)//21
  },100)    
}


foo.call({ids:24});
var ids=21;
// setTimeout(function(){
//   foo.call({ids:24});
// },100)


function zmlObj(){
       
    var obj={
      names:'helln',
      age:20,
      say:(pm)=>{
        console.log(this.names)
      }
    }


    obj.say();//undefined 函数say虽定义在对象obj中，但是，其中的this时运行时才确定的对象，obj.say中的this对象所运行的作用域正是在点击按钮时执行的zmlObj函数的环境内部，而zmlObj中并未定义names，因此，输出undefined

}

 </script>


 <button type="button" onclick="testThisss()">this</button>
</body>
</html>
