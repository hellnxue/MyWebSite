<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>writer title here</title>
<link href="../../CSS课程/CSS/CSSUtil.css" rel="stylesheet" type="text/css"/>
<link href="panel.css" rel="stylesheet" type="text/css"/>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>

<body>
	<div id="wrap">
		<fieldset class="enter">
		 <legend>try.....</legend>
			 <input type="button"  value="let-块级作用域" onClick="test1()"/> 
			
			<input type="button"  value="测试语法" onClick="test11()"/> 
			
			<input type="button"  value="函数参数默认值" onClick="test2()"/> 
			
			<input type="button"  value="重复声明" onClick="test3(11)"/> 
			 
		    <input type="button"  value="ES5变量提升导致的问题" onClick="test4()"/>

		     <input type="button"  value="闭包模拟局部作用域" onClick="test5()"/>
			 <input type="button"  value="测试" onClick="test6()"/>
			 
			 <input type="button"  value="不能在函数内部重新声明参数" onClick="test7()"/>

			  <input type="button"  value="ES6的块级作用域" onClick="test8()"/>

			  <input type="button"  value="ES5没有块级作用域" onClick="test9()"/>

			  <input type="button"  value="do表达式" onClick="test10()"/>
		</fieldset>
		
		<fieldset class="out">
		 <legend>out.....</legend>
		 <div id="out">
		   result here......
		 </div>	 
		 
			
			  
		</fieldset>
		
		 
		 
		 <div id="btn">
		   <input type="button"  value="clear" onClick="clears()"/> 
		 </div>	 
		 
			
			  
		 
	</div>
	
	<script type="text/javascript" src="../../js/jquery-1.8.2.min.js"></script>
	
	<script>
	
	/*公共方法-消息显示*/
	function commonShow(msg){
	 
	  $("#out").append("<br/>"+String(msg));//不能用msg.toString() 因为boolean类型用在此处会报错
	}
	
	function clears(){
	   $("#out").html("");
	}
	
	 
	 //-------------------------------------------------------------------
	 
	  var a=10;
	  console.log(window.a);//10  
	  
	  let b=20;
	  console.log(window.b); //undefined let声明的全局变量不会成为window对象的属性
		 
	   
	  
	
	function test1(){
	
	 //let只在代码块中有效
	 {
	   var a="hello";
	   let b="world";
	   commonShow("let b:"+b);
	 }
		
		commonShow(a);
		//commonShow(b);//ReferenceError: b is not defined
		
	  //不能在定义之前使用let
	  /* commonShow(c);//error 
	   let c="sir"; */
	   
	  //TDZ 即使存在全局变量temp,但只要在代码块里有let命令，就不能在let之前使用该变量 typeof类型判断标识符也不可以 
	   commonShow( temp);
	   var temp=0;
	   if(1){
		 try{
		   commonShow(temp);//error
		   commonShow(typeof tempVariable);//error
		 }catch(e){
		   commonShow("error:"+e );
		 }
		 
		 let temp=10;
		 commonShow(temp); 
	   
	   } 
	   
	   
	  
	}
	 
	function test11(){
		
		//变量未被定义时直接使用导致语法错误
	   /*console.log(variable);*/
	   //对于未定义的变量，只有一种用处，那就是使用typeof判断它的类型，这种说法是在出现let之前 ！
	   console.log(typeof variable);//undefined 
	   
	   //而在定义变量之前使用该变量不会导致语法错误，会有一个变量提升的过程，只要在js里定义了，那么就能找到该变量，只不过在定义且初始化之前使用此变量，此变量的值是undefined，因为没有初始化。
	   console.log( temp);//undefined
	   console.log( typeof temp );//undefined 是字符串类型的undefined
	   var temp=10;//此处已经定义了变量，并且初始化了
	   
	  /* console.log(tempLet);//导致语法错误
		 console.log(typeof tempLet);
	   let tempLet=10;*/
	   
	}
	
	 
	
	
	/*IE10.0不支持参数有默认值哎*/
	function test2(x=2){
	  
	  commonShow(x);
	 }  
	 
	function test3(arg){
	
	   //error
	   /* let arg=1;*/
	
	   {
		 let arg=1;
		 commonShow(arg);
	   }
	}
	
	
	/*没见过的问题-很新奇，很专业*/
	var date=new Date();
	function test4(){
	
	 commonShow(date);//undefined 原因在于函数内部，又声明了一次变量，变量提升，值是undefined,即使判断中使用的是false
	 
	  if(false){
		var date="hello world";
	  }
	}

	// 闭包模拟局部作用域(块级作用域)
	function test5(){
		var a = [];
		for (var i = 0; i < 10; i++) {
		  a[i] = (function (pm) {
		  	 
		  	 return function(){
		  	 	console.log(pm);
		  	 }
		    
		  })(i);
		}

		 a[6]();
	}

 	/*暂时性死区*/
	function bar(x = y, y = 2) {
	  return [x, y];
	} 

	//变量y不能再定义之前使用如果是bar(x = 2, y = x) 的话没有问题，因为x已经定义了的
	function test6(){
		bar();//ReferenceError: can't access lexical declaration `y' before initialization
	}

	function test7(arg){
		// let arg=1;//error
		{
			let arg=1;//right
		}
	}

	/*ES6块级作用域  if语句块的外层区域不受if语句块的影响哎*/
	function test8(){
		let n=5;
		if (true) {
			let n=10;
		}
		console.log(n);//5
	}
 
 	// ES5没有块级作用域，只有全局作用域和函数作用域 
 	//if语句块影响了if语句块外的作用域，
    var tmp=123;
	function test9(){
		
		 if (false) {
		 	var tmp=321;
		 }

		 console.log(name);//undefined 输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。
		 
	}
	/*do表达式*/
	
	function test10(){
		/*let x = do {
		  let t =  t * t + 1;
		};


		console.log(x);//没输出哎.....?*/




	}
	
	</script>
</body>
</html>
