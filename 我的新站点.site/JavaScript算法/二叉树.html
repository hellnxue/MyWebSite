<!--
 * @Description: 
 * @Author: lxp
 * @Date: 2021-08-04 20:56:35
 * @LastEditTime: 2021-08-20 15:03:30
 * @LastEditors: lxp
-->
 
<!DOCTYPE html  >
<html >
<head>
<meta  charset="utf-8" />
<title>二叉树</title>
<style>
   
    .box{
        display: flex;
        width: 600px;
        height: 300px;
        border: 1px solid gold;
        
    }

    .box1{
        background-color: rgb(250, 167, 167);
        width: 200px;
        height: 200px;
        border: 1px solid rgb(240, 93, 88);
    }

    .box2{
        background-color: #c7f1aa;
        width: 200px;
        border: 1px solid rgb(24, 230, 76);
    }
    .box3{
        align-self: flex-start;
        background-color: #abcdef;
        width: 200px;
        border: 1px solid rgb(71, 161, 221);
    }
</style>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>

<body>
 <div class="box">
     <div class="box1">设置了固定宽高的弹性子元素</div>
     <div class="box2">设置了固定宽度，未设置固定高度，高度被拉伸至父元素的高度</div>
     <div class="box3">设置了固定宽度，未设置固定高度，子元素自适应高度</div>
 </div>
<script>       

    let timer=null
    timer=setTimeout(()=>{
        console.log('执行.........................')

    },1000)


    setTimeout(()=>{
        console.log('取消执行.........................')

        clearTimeout(timer)

    },1000)

    setTimeout(()=>{
        console.log('hello world........................')


    },1000)
      function defaultCompare(a, b) {
        if (a === b) {
            return Compare.EQUALS;
        }
        return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;
    }

      const Compare = {
        LESS_THAN: -1,
        BIGGER_THAN: 1,
        EQUALS: 0
    };

      const DOES_NOT_EXIST = -1;

    class Node{
        constructor(key){
            this.key=key
            this.left=null
            this.right=null
        }
    }

    class BinarySearchTree{
        constructor(compareFn=defaultCompare){
            this.compareFn=compareFn
            this.root=null
        }
        insert(key) { 
            if (this.root == null) { // {1} 
                this.root = new Node(key); // {2} 
            } else { 
                this.insertNode(this.root, key); // {3} 
            } 
        }

        insertNode(node, key) {
            if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
                // {4}
                if (node.left == null) {
                    // {5}
                    node.left = new Node(key) // {6}
                } else {
                    this.insertNode(node.left, key) // {7}
                }
            } else {
                if (node.right == null) {
                    // {8}
                    node.right = new Node(key) // {9}
                } else {
                    this.insertNode(node.right, key) // {10}
                }
            }
        }


        //中序遍历
        inOrderTraverse(callback){
            this.inOrderTraverseNode(this.root,callback)
        }

        inOrderTraverseNode(node,callback){
            console.log('node.key==',node?.key??'没有key');

            if(node!=null){
                this.inOrderTraverseNode(node.left,callback)
                callback(node.key)
                this.inOrderTraverseNode(node.right,callback)
            }
        }

        //先序遍历
        preOrderTraverse(callback){
            this.preOrderTraverseNode(this.root,callback)
        }

        preOrderTraverseNode(node,callback){
            if(node!=null){
                callback(node.key)
                this.preOrderTraverseNode(node.left,callback)
                this.preOrderTraverseNode(node.right,callback)
            }
        }


        //后序遍历
        postOrderTraverse(callback){
            this.postOrderTraverseNode(this.root,callback)
        }

        postOrderTraverseNode(node,callback){
            console.log('node.key==',node?.key??'没有key');

            if(node!=null){
                this.postOrderTraverseNode(node.left,callback)
                this.postOrderTraverseNode(node.right,callback)
                callback(node.key)

            }
        }


        min(){
           return this.minNode(this.root)
        }

        minNode(node){
             
            let current=node
            while(current!=null&&current.left!=null){
                current=current.left
            }
            return current 
        }

        max(){
            return this.maxNode(this.root)
        }

        maxNode(node){
            let current=node 
            while(current!=null&&current.right!=null){
                current=current.right
            }
            return current 
        }
        
    }

    const tree=new BinarySearchTree()
    tree.insert(11)
    tree.insert(7); 
    tree.insert(15); 
    tree.insert(5); 
    tree.insert(3); 
    tree.insert(9); 
    tree.insert(8); 
    tree.insert(10); 
    tree.insert(13); 
    tree.insert(12);
    tree.insert(14); 
    tree.insert(20); 
    tree.insert(18); 
    tree.insert(25);
    tree.insert(6);

    console.log('tree===',tree);
    // console.log('中序遍历排序------------------');

    const printNode = (value) => console.log('value==',value); // {6} 
    // tree.inOrderTraverse(printNode);

    console.log('后序遍历排序------------------');
    tree.postOrderTraverse(printNode);

    console.log('min==',tree.min());
    console.log('max==',tree.max());


</script> 
</body>
</html>
