<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Promise</title>
 
<style>

  body{
    /*background: radial-gradient(#bbd5e0, #3ab7ef);*/
    height: 960px;
  }


    button,[type='button']{
      background: #abcdef;  
      border: 0;
      display:  block;
      height: 3em;
      line-height: 3em;
      padding: 0 2em;
      margin-bottom: 20px;
      border-radius: .5em;
      color: #fff;
      font-size: 18px;
      box-shadow: 0 0 20px #fff;   
    }   
</style>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>

<body >

<button type="button" onclick="testThen()">Promise的实例方法then()</button>
 
<button type="button" onclick="immdTest()">Promise新建后立即执行</button>

<button type="button" onclick="loadImageTest()">Promise加载图片案例</button>

<button type="button" onclick="AjaxTest()">Promise对象实现ajax</button>
<button type="button" onclick="paramTest()">Promise的实例作为resolve的参数</button>

<button type="button" onclick="catchErrorTest()">捕获错误</button>

<button type="button" onclick="catchTest()">Promise捕获异常catch</button>

<button type="button" onclick="codeAfterTest()">Promise的resolve()之后最好不写语句，放在then()方法中</button>

<button type="button" onclick="returnPromise()">Promise返回另一个promise</button>

<script type="text/javascript">
  function returnPromise(){

    var p1=new Promise((resove,reject)=>{
      setTimeout(()=>{
        reject(new Error('fail...'))
      },3000)
    })


    var p2=new Promise((resove,reject)=>{
      setTimeout(()=>{
        console.log('p2 success')
        reject(p1)
      },1000)
    })

    p2.then((data)=>{
      console.log('then ....data')
      console.log(data)
    }).catch((error)=>{
      console.log('catch ....data')
      console.log(error)
    })

    setTimeout(()=>{
        console.log('hello ')
        
      },4000)

  }

</script>
 <script type="text/javascript">
    function timeout(ms){
      return new Promise((resove,reject)=>{
        setTimeout(resove,ms,'done');
      })
    }

    function testThen(){
       timeout(3000).then((value)=>{
         console.log(value);
        });


      /* 
      setTimeout可以传三个参数，第三个参数会作为第一个参数的的方法参数传入
      setTimeout((msg)=>{
        console.log(msg)
      },1000,'hello world sir') */
    }


    /*

      welcome...   
      other script......1
      other script......2
      other script......3
      other script......4   
      resove param......  
      延迟执行方法。。。。。。


      Promise 新建后立即执行，所以首先输出的是Promise。
      然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，
      所以 promise param最后输出。

    */
    function immdTest(){
      var promise=new Promise(function(resove,reject){
        console.log('welcome...');
        resove('resove param......');
      })

      promise.then((prm)=>{
        console.log(prm)
      });

      console.log('other script......1')
      console.log('other script......2')
      console.log('other script......3')
      console.log('other script......4')

      setTimeout(()=>{
        console.log('延迟执行方法。。。。。。')
      },2000)
    }


    function loadImageTest(){
      let url='../../../image/mxx.jpg';

      let promise=new Promise(function(resove,reject){

         let img=new Image();
        
         // 监测图片加载img.src = url是否成功
         img.onload=function(){
           resove(img);
         }

        img.onerror = function() {
            reject(new Error('Could not load image at ' + url));
          };

        img.src = url;


      });

      promise.then((img)=>{
        console.log(img); //<img src="../../../image/mxx.jpg">
      }).catch((error)=>{
        console.log(error)
      })
    }



    const getJSON=function(url){
      const promise=new Promise((resove,reject)=>{

        const handler=function(ret){
          if (this.readyState!=4) {
            return;
          }

          if (this.status===200) {
            // console.log(this)
            resove(this.response);
          }else{
            reject(new Error(this.statusText))
          }

        };

        const client=new XMLHttpRequest();
        client.open('GET',url);
        client.onreadystatechange=handler;
        client.responseType='json';
        client.setRequestHeader('Accept','application/json');
        // client.setRequestHeader('Accept','application/json');
        client.send();

      });

       return promise;
    }


    function AjaxTest(){
      // getJSON('package.json').then(function(response){
      //   console.log('成功啦')
      //   console.log(JSON.stringify(response));
      //   return response.version;
        
      // },function(error){
      //   console.log( error)
      // }).then((data)=>{
      //   console.log(data)
      // })

      //then()方法的链式调用，then方法的函数参数中的参数，是上一步(可能是promise，也可能是then())返回的值
      getJSON('package.json').then(function(response){
        console.log('成功啦')
 
        console.log( response )
        
      },function(error){
        console.log('fail....')
        console.log( error)
 
        console.log(JSON.stringify(response));//{"name":"app","version":"1.0.0","description":"json文件","main":"main.js"}
        return  getJSON('package.json');
        
      }).then((data)=>{
        console.log('链式调用。。。。。。')
        console.log(JSON.stringify(data))//{"name":"app","version":"1.0.0","description":"json文件","main":"main.js"}
      }).catch((err)=>{//捕获错误
        console.log(err);
 
      }) 



    }

    /*
      ok   
      Error: test   
    */
    function catchTest(){
      const promise=new Promise((resolve,reject)=>{
        resolve('ok');
        setTimeout(()=>{
          throw new Error('test')
        },0)
      });

      promise.then((value)=>{
        console.log(value);
      })
    }

    //此处resolve之后的代码不会再执行
    function codeAfterTest(){
      const promise=new Promise((resolve,reject)=>{
        return resolve('ok');
        setTimeout(()=>{
          throw new Error('test')
        },0)
      });

      promise.then((value)=>{
        console.log(value);
      })
    }
   
  /*
  from p2.......... Promise对象.html:179:10
  from p1.......... Promise对象.html:172:10
  Error: "fail"
  */
 function paramTest(){
   const p1=new Promise((resolve,reject)=>{
     setTimeout(()=>{
         console.log('from p1..........')
         reject(new Error('fail'));
     }, 3000);
   });

   const p2=new Promise((resolve,reject)=>{
     setTimeout(()=>{
         console.log('from p2..........')
         resolve(p1);
     }, 1000);
   });

   p2.then(result => {
    console.log('hello world');
    console.log(result);
   }).catch(error => console.log(error));
 }

/*
  first 
  carry on...... 
  ok  
  Error: test
*/
 function catchErrorTest(){
   const promise=new Promise((resolve,reject)=>{
     resolve('ok');
     setTimeout(()=>{throw new Error('test')},0);//错误会在Promise函数体外抛出，即使setTimeout设置了0s
    // throw new Error('test')
    console.log('first')

   })

   promise.then((value)=>{
     console.log(value);
   }).catch((error)=>{
     console.log(error)
   })

   console.log('carry on......')
 }

 </script>


 
</body>
</html>