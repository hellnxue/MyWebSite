<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>属性类型和访问器属性</title>
<script type="text/javascript" src="../../js/jquery-1.8.2.min.js"></script>
<script type="text/javascript">
$(function(){
	$("#d1").on("click",function(){
	  var pp={
	     name:"jack",
		 age:20
	  };
	  
	  console.log("name1="+pp.name);
	  
	  Object.defineProperty(pp,"name",{
	     writable:false //false代表不可写
		 
		 
	  })
 
	 
	  pp.name="tom";
	  console.log("name2="+pp.name);//jack
	  
	  console.log(pp.age);//20
	  
	  Object.defineProperty(pp,"age",{
	    configurable:false
	  });
 
	  delete pp.age;
	  
	  console.log(pp.age);//20
	  
	 
	/* 
	//将configurable设置为false之后，再配置除writable属性之外的特性都会导致报错奥~~
	Object.defineProperty(pp,"age",{
	    enumerable:false
	  });
	  
	  for (var vb in emObj) {
	  	console.log(vb);//age
	  }*/

	  
	  
	});
	
	$(":input:eq(1)").on("click",function(){
	   var book={
	      _year:2004,//前面的下划线是一种常用记号，用于表示只能通过对象方法访问的属性哎
		  edition:1
	   };
	   
	   Object.defineProperty(book,"year",{
	     get:function(){
		   return "hello world";
		 } ,
		 /*若只定义get不定义set方法，代表访问器属性year 是只读的，不可写*/
		 set:function(newValue){
		    this._year=newValue;
			this.edition+=newValue-2004;
		 } 
	   });
	   book.year=2005;
	   console.log(book.edition);//2
	   console.log(book._year);//2005  使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化
	   
	   
	});


});

/*枚举对象属性，可用enumerable特性配置属性是否可枚举*/
function enumer(){
	 var emObj={
	     name:"jack",
		 age:20
	  };


	  for (var vb in emObj) {
	  	console.log(vb);//name age
	  }

	 console.log('----------------------------------')
	  Object.defineProperty(emObj,'name',{
	  	enumerable:false
	  });

	  for (var vb in emObj) {
	  	console.log(vb);//age
	  }

}

/*构造函数*/
function Person(){
	this.idol='me';
}
Person.prototype.name='helln';
Person.prototype.age=20;
Person.prototype.sayName=function(){
	console.log(this.name);
}

// Person.prototype.idol='you';
Person.prototype.getIdol=function(){

	console.log(this.idol);//me  this指向构造函数的实例对象
}


/*此处的this根据调用方法的对象的不用而不同，若是构造函数的实例对象调用getThis ,this指向实例对象。若是构造函数的原型对象直接调用getThis()，this指向构造函数的原型对象*/
Person.prototype.getThis=function(){

	console.log(this);  //实例对象or原型对象 
}


/*可以用delete删除构造函数的原型对象上的属性*/
function test(){

	var p1=new Person();
	console.log(p1.name);
    delete Object.getPrototypeOf(p1).name;  //or delete Person.prototype.name; 
	console.log(p1.name);//undefined

}

function testThis(){
	 var p1=new Person();
	 p1.getIdol();//me
	 p1.idol='you';
	 p1.getIdol();//you

	p1.getThis();
	Person.prototype.getThis();
	
}


function definedObj(){
	var obj={
		name:'helln'
	};

	Object.defineProperty(obj,"age",{value:"20"});//用属性描述器定义的属性是默认只读的
	age=30;
	console.log(obj.age)//20

}

/*访问对象中的属性有两种方法奥~*/
function objFun(){
	var obj={
		name:'test',
		fun:function(){
			console.log('hello');
		}
	}
	//方法一：用.
	console.log(obj.name);
	//方法二：用类似访问数组的方式，传入字符串
	console.log(obj['name']);
	//访问对象中的方法可以这样。。。同最简单的obj.fun()哎
	obj['fun']();
}

function descriptor(){
	 
	var obj=Object.defineProperty({name:'helln'},"age",{value:"20",enumerable: false});
	var temp=Object.getOwnPropertyDescriptor(obj,'age');
	console.log(temp)


	

}

 



/*访问器属性*/
function accessor(){
	var book={
		_year:2004,
		editor:1
	}

	Object.defineProperty(book,"year",{
		get:function(){
			return this._year;
		},
		set:function(value){
			if (value>2004) {
				this._year=value;
				this.editor+=value-2004;
			}
		}
	});

	book.year=2005;
	console.log(book._year)
}

function observeProto(){
	var book={};

	Object.defineProperty(book,"year",{
	     get(){
	       console.log('监测到year了')
		   return this._year;
		 } ,
	 
		 set(newValue){
		 	console.log('year赋值')
		    this._year=newValue;
			 
		 } 
	   });
	   book.year=2005;
	   console.log(book.year)
}
</script>
</head>

<body>
<input type="button"  name="d1" id="d1" value="数据属性"/></br>
<input type="button"  value="数据属性Enumerable" onclick="enumer()" /></br>
<input type="button" value="访问器属性" onclick="accessor()" /></br>
<input type="button" value="用delete删除原型对象上的属性" onclick="test()" /></br>

<input type="button" value="原型对象的方法里的this指向" onclick="testThis()" /></br>



<input type="button"    value="用属性描述器定义的属性是默认只读的" onclick="definedObj()" /></br>


<input type="button"    value="对象中的方法调用" onclick="objFun()" /></br>
<input type="button"    value="对象属性的描述对象getOwnPropertyDescriptor" onclick="descriptor()" /></br>

<input type="button" value="对象属性检测" onclick="observeProto();">
</body>
</html>
