<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>无标题文档</title>
<link href="../../CSS/CSSUtil.css" rel="stylesheet" type="text/css"/>
<link href="assets/note1.css" rel="stylesheet" type="text/css"/>
<style>

	.title{
		margin:50px 15px;
		font-size: 16px;
		text-align: center;

	}

	.container{
		width: 50%;
		min-height: 100px;
		margin: 0 auto;
		border: 1px solid purple;
	}
 
 
</style>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>

<body>

<h3 class="title">设置了较小宽度的块级元素与行内元素不会并排在一行</h3>
<div class="block-vs-inline">
	<p>hello paragraph</p>
	<span>hello span</span>
</div>
 
 
<h3 class="title">绝对定位的元素，相对于设置了relative或position或fixed的最近父元素的padding box左上角</h3>
<div class="m-position">
	<div class="inner">inner</div>
</div>

<h3 onclick="testNone()"  class="title">设置了display:none;的元素，js DOM也能选中</h3>
<div class="container">
	<p class="m-none">this is paragraph1</p>
	<p class="m-none">this is paragraph2</p>
	<p class="m-none none">this is paragraph3</p>

</div>
 <script type="text/javascript">
 	function testNone(){
 		let dom=document.getElementsByClassName('m-none');
 		let ary=Array.prototype.slice.call(dom);
 		ary.forEach((item)=>{
 			console.log(item.textContent)
 		})
 	}
 </script>

<h3 class="title" onclick="testNone()">绝对定位的元素水平垂直居中</h3>
<div class="container position-test">
	<div class="inner">inner</div>
</div>

<h3 class="title">用背景background制造容器边角选中的样式</h3>
<div class="bg-selected">
	<div class="label">标签</div>
	<div class="label">标签</div>
	<div class="label">标签</div>
	<div class="label">标签</div>
	
</div>


<h3 class="title">flex布局，左边栏占满多余空间的同时，内容过长时不会撑大整体的高度布局，也就是.f-wrap的布局以.right的内容为主，内容过多时自动增大，而左边栏内容过多要有滚动条出现。</h3>
<div class="f-wrap">
	<div class="left">
		<div class="top">top</div>
		<div class="bottom">
			你可能已经注意到 Vue 组件非常类似于自定义元素——它是 Web 组件规范 的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 Slot API

			与 is attribute。但是，还是有几个关键差别：

			    Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE11 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。

			    Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。
		</div>
	</div>
	<div class="right">
		尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进  组件，提供更为复杂的模板和逻辑，而不会影响到父应用。

在一个大型应用中，有必要将整个应用程序划分为多个组件，以使开发更易管理。在后续教程中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：
尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 < 组件，提供更为复杂的模板和逻辑，而不会影响到父应用。

在一个大型应用中，有必要将整个应用程序划分为多个组件，以使开发更易管理。在后续教程中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：
尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 <  组件，提供更为复杂的模板和逻辑，而不会影响到父应用。

在一个大型应用中，有必要将整个应用程序划分为多个组件，以使开发更易管理。在后续教程中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：
尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 <  组件，提供更为复杂的模板和逻辑，而不会影响到父应用。

在一个大型应用中，有必要将整个应用程序划分为多个组件，以使开发更易管理。在后续教程中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：
	</div>
</div>


<h5 class="title">border-radius将元素制作为椭圆</h5>
<div class="bdrd"></div>



<h5 class="title">文字渐变</h5>
<p class="text-color-gradient">设置了渐变色的文字奥~</div>

</body>
</html>
