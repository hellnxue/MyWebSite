<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>writer title here</title>
<link href="../../CSS课程/CSS/CSSUtil.css" rel="stylesheet" type="text/css"/>
<link href="../../util/css/panel.css" rel="stylesheet" type="text/css"/>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>

<body>
	<div id="wrap">
		<fieldset class="enter">
		 <legend>try.....</legend>
			 <input type="button"  value="aa" id="test1" class="btn-info"/> 
			
			<input type="button"  value="类不能直接调用" id="test2" class="btn-info"/> 
			
			<input type="button"  value="不存在变量提升" id="test3" class="btn-info"/> 
			
			<input type="button"  value="dd" id="test4" class="btn-info"/> 
			 
		    <input type="button"  value="ee" id="test5" class="btn-info"/>
			
			  
		</fieldset>
		
		<fieldset class="out">
		 <legend>out.....</legend>
		 <div id="out">
		   result here......
		 </div>	 
	  
		</fieldset>
				 
		 <div id="btn">
		   <input type="button"  value="clear" onClick="clears()" class="btn-clear"/> 
		 </div>	 			  
		 
	</div>
	
	<script type="text/javascript" src="../../js/jquery-1.8.2.min.js"></script>
	
	<script>
		/*公共方法-消息显示*/
		function commonShow(msg){
		 
		  $("#out").append("<br/>"+String(msg));//不能用msg.toString() 因为boolean类型用在此处会报错
		}
		
		function clears(){
		   $("#out").html("");
		}
	
		$(function(){
		
		   $("#test1").on("click",function(){
		    /*  function Person(name,age){
			  	this.name=name;
				this.age=age;
			  }
			
			  Person.prototype={
			     love:"apple"
			  };
			  var p=new Person("小新",20);
			 
			  console.log(Person.prototype.isPrototypeOf(p));//true
			  console.log(Object.getPrototypeOf(p)==Person.prototype);//true
			  console.log(Person.prototype);//Object
			  console.log(Object.getPrototypeOf(p) );//Object*/
			  
			  class Person{
			  
			    constructor(name,age){
				  this.name=name;
				  this.age=age;
				}
				
				love(){
				  console.log(this.name);
				}
				
			  }
			 
			  var p=new Person("小新",20);
			  
			  /*assign方法向原型对象添加多个方法*/
			   Object.assign(Person.prototype,{
			    toString(){
				  console.log("tostring......");
				}
			  });
			   console.log(p.name);
			    p.love() ;
				p.toString();
				
			  console.log(Person.prototype.constructor);//Person
			  console.log(p.constructor);//Person
			  
			  //类中的所有方法都是不可枚举的,ES5中得原型对象中自定义的方法是可以枚举的
			  console.log(Object.keys(Person.prototype));// ["toString"] 不知道这个toString方法为什么可以枚举出来，love方法没有
			  console.log(Object.getOwnPropertyNames(Person.prototype));// ["constructor", "love", "toString"]
				
			  console.log("----------------------------------------------------------");
				/*类的属性名，可以采用表达式。*/
				let methodName="say";
				class Squre{
				  [methodName](){
					console.log("hello");
				  }
				}
				
				var sq=new Squre();
				sq.say();
				
				console.log(s);
				 
				  
				 
				
			  
		   });
		   
		    $("#test2").on("click",function(){
		       
			  class Person{
			  
			    constructor(name,age){
				  this.name=name;
				  this.age=age;
				}
				
				love(){
				  console.log(this.name);
				}
				
			  }
			 
			  var p=new Person("小新",20);
			  /*类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。*/
			  //Person();//TypeError: class constructors must be invoked with |new|
		   });
		   
		    $("#test3").on("click",function(){
		     
			    var p=new Person("小新",20);
			   class Person{
			  
			    constructor(name,age){
				  this.name=name;
				  this.age=age;
				}
				
				love(){
				  console.log(this.name);
				}
				
			  }
			
			  
			  
			  
			  
		   });
		   
		    $("#test4").on("click",function(){
		     console.log(4);
		   });
		   
		    $("#test5").on("click",function(){
		     console.log(5);
		   });
		});
	 
	
	</script>
</body>
</html>
