<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>数组的扩展-扩展运算符</title>
 
<style>

  body{
    /* background: radial-gradient(#bbd5e0, #3ab7ef); */
    height: 960px;
  }


    button,[type='button']{
      background: #abcdef;  
      border: 0;
      display:  block;
      height: 3em;
      line-height: 3em;
      padding: 0 2em;
      margin-bottom: 20px;
      border-radius: .5em;
      color: #fff;
      font-size: 18px;
      box-shadow: 0 0 20px #fff; }     
</style>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>

<body >

<button type="button" onclick="findElementInAry()">Set数据结构</button>

<button type="button" onclick="setBL()">Set数据结构的遍历</button>
<button type="button" onclick="MapTest()">Map数据结构</button>

<button type="button" onclick="setData()">立即执行函数给对象赋值</button>


<button type="button" onclick="kzTest()">扩展运算符</button>
<div>
  <div id="weakNode">测试用DOM节点作为WeakMap的键名</div>
</div>

<button type="button" onclick="weakMapTest()">WeakMap</button>

<script type="text/javascript">


function weakMapTest(){

 
  console.log('=============DOM节点作为WeakMap的键名=============')
  let el=document.querySelector('#weakNode');
  let wmap=new WeakMap();
  wmap.set(el,'helln');
  console.log(wmap.get(el));//测试用DOM节点作为WeakMap的键名
  //删除DOM节点
  el.parentNode.removeChild(el);
  el=document.querySelector('#weakNode');
  console.log( el,wmap.get(el));//null undefined




  console.log('=============对象作为WeakMap的键名=============')
  let omap=new WeakMap();
  let obj={a:1};
  omap.set(obj,'hello');
  console.log(omap.get(obj));
  obj=null;
  console.log(omap.get(obj));

}



 let mmap=new Map();
 let obj={a:1};
  mmap.set(obj,'this is object');
  console.log(mmap.get(obj))
 function  kzTest(){
  // let obj={b:2}
  // mmap.set(obj,'helln');
   
  //  for(let map of mmap){
  //    console.log('hello==',map)
  //  }


  //  console.log(mmap[Symbol.iterator] === mmap.entries)





   const map = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');


  let arry=[1,2,3,4,5,6]
  let arryb=[];
  arryb.push(...arry)
  console.log(...arryb )

  let obj = Object.create(null);
  console.log('obj',JSON.stringify(obj))


  let myMap = new Map().set('yes', true).set('no', false);

  let rl=JSON.stringify(myMap);
  console.log(JSON.stringify(rl))


  let kmap=new Map();
  let objss={a:2,b:[1,2,3],c:{cc:11}};

  kmap.set(1,objss);
  console.log(kmap.get(1))
  objss=null;
  console.log(kmap.get(1))
 }
    
  function findElementInAry(){

    /*在Set中，两个对象总是不相等*/
    var ary=[{a:1,b:2},{a:2,b:2},{a:3,b:2}];
    const i=new Set(ary);


    let rlt=i.has({a:3,b:2});//false
    console.log(rlt);//false


    /*在Set内部，两个NaN是相等的*/
    var ary1=[1,2,3,4,NaN,NaN];

    var set=new Set(ary1);
    console.log(set);//[ 1, 2, 3, 4, NaN ]

    /*has()方法判断一个元素时，同indexOf()一样用全等===*/
    var rlt1=set.has('4');
    console.log(rlt1);//false


    /* Array.from方法可以将 Set 结构转为数组。*/
    let otherSet=new Set([1,2,3,4]);
    let ary2=Array.prototype.slice.call(otherSet,0);
    console.log(ary2)//空数组......why,Set结构也是类数组哎。。。。。

    let ary3=Array.from(otherSet);
    console.log(ary3);//Array [ 1, 2, 3, 4 ]
    
    //利用扩展运算符也可以将Set数据结构转为数组
    //扩展运算符(...)内部使用for...of循环，所以也可用于set结构
     
    let ary4=[...otherSet];
    console.log(ary4)//Array [ 1, 2, 3, 4 ]


    /*数据去重复*/

    let aryNotRepeat=Array.from(new Set([1,2,2,3,3]));
    console.log(aryNotRepeat);Array [ 1, 2, 3 ] 





     
  }

  function MapTest(){
    let a=new Object();
    let b=new Object();

    let c={};
    //对象的key都是字符串，就算不是，也会转成字符串
    c[a]='hello';
    c[b]='hello1'
    console.log(c[a])//hello1
    console.log(c[b])//hello1


    let ary=[1,2,3,4];
    ary.forEach((item,index)=>{
      console.log(item+": "+index)
    })



    //Map构造函数接受一个二维数组作为参数
    var tary=[['name','Darcy'],['love','lucy']];
    const map=new Map(tary);
    console.log(map)


    //二维数组作为Map参数时所执行的算法，forEach的函数参数用的应该是解构赋值吧.....?
    const map1=new Map();
    tary.forEach(([item,index])=>{
      map1.set(item,index);
    });
    console.log(map1);
    console.log(typeof map1.get('haohao'))//undefined
    
    map1.set('123',123);
    // map1.set(123,321);
    console.log(map1.has(123))//false

    console.log(map1.keys());//MapIterator {"name", "love", "123"}
    console.log('map的遍历方法ForEach................')
    map1.forEach((value,key,map)=>{
      console.log('Key:%s, Vlaue:%s', key,value)
    })


    console.log(null==undefined)//true
  }

  function setData(){
    let obj={};

    (function(pobj){
      pobj.name='helln';
    })(obj);

    console.log(JSON.stringify( obj))//{"name":"helln"}

   

    try{
       throw new Error('failed to require "' + p + '"');
    }catch(e){
      console.log(e)
    }
  }


  function setBL(){
     
    let a=[1,2,3,4];
    let b=[2,4,6];

    let c=[...a,...b];
    console.log(c)//[1,2,3,4,2,4,6]

    //去重复-取并集
    let d=[...new Set([...a,...b])];
    console.log(d)



    //两个存有简单类型数据的数组，取交集和差集的算法，利用indexOf()方法。。。

    //取交集
    let rlt=a.filter((item,index)=>{
      return b.indexOf(item)!=-1;
    });
    console.log(rlt);//[2,4]


    //取差集
    let cj=a.filter((item,index)=>{
      return b.indexOf(item)==-1;
    })
    console.log(cj)//[1,3]



    //Array.from
    let set=new Set([1,2,3]);
    let tary=Array.from(set,(val)=>val*2);
    console.log(tary)//[2,4,6];
     
  }
 

 </script>


 
</body>
</html>
