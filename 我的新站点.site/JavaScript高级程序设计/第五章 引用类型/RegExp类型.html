<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<title>无标题文档</title>
<script type="text/javascript" src="../../js/jquery-1.8.2.min.js"></script>
<script type="text/javascript">
   var isTrue=false;
    //验证公共函数
	function validatorUtil(id,errMsg){
		
		if(arguments.length==2){
			$(id).after("<label id=\"errInfo\" style=\"color:#f60\">"+errMsg+"！<label>");
			isTrue=true;
			return false;
			
		}else{
			$(id).after("");
			isTrue=true;
		}
		
		
	}

$(function(){
	  $("#reg1").on("click",function(){
		   
		  var pt1=/[bc]at/i;
		  console.log("pt1=="+pt1.test("ca1t,bast,tat"));
		  
		  
		  
		  
		  var pt2=/.{4}/;
		  var str1="201507";//匹配2015
		  console.log(pt2.test(str1));
		  console.log(str1.replace(pt2,"a"));//a07
		   
		  //测试捕获组
		  var str2=str1.replace(/(.{2})/g, '$1-');
		  var str3=str1.replace(/(.{3})/g, '$1-');
		  var str4=str1.replace(/(.{4})/g, '$1-');
		  var str5=str1.replace(/(.{4})(.{2})/g, '$2-');
		  var str6=str1.replace(/(.{5})(.{2})/g, '$2-');
		  console.log("str1=="+str1);
		  console.log("str2=="+str2);
		  console.log("str3=="+str3);
		  console.log("str4=="+str4);
		  console.log("str5=="+str5);//07-（按顺序捕获，(.{4})匹配了2015，剩下的(.{2})去匹配07）
		  console.log("str6=="+str6);//201507（(.{5})匹配20150，剩下的7用(.{2})捕获组去匹配时，不够数，因此'$2-'代表一个空值，即不匹配）
		  
		  console.log("kkkkk="+$("#hihi")[0]);
		  if($("#hihi").val()){
		      console.log("llllllllllllllllllllllllllll");
		  }
	});



	 $("#intFloat").on("keyup",function(){
	    
		var regInt=/^[0-9]*[1-9][0-9]*$/;//正整数正则
		var regFloat=/^\d{1,}\.{0,1}\d{1,}$/;//浮点正则
		var js=$("#intFloat").val();
		
		 var hjs=parseFloat(js);
		 var ijs=parseInt(js);
		 var fmin=parseFloat(this.dataset.min);
		 var fmax=parseFloat(this.dataset.max);
		 
		 var imin=parseFloat(this.dataset.min);
		 var imax=parseFloat(this.dataset.max);
		
		var id="#intFloat";
		
		if(js==""){
			
		   validatorUtil(id,"请填写基数");
			   
		}else if( regInt.test(js)){
			console.log("int");
 			if(ijs<imin||ijs>imax){
				 
				validatorUtil(id,"基数范围"+fmin+"~"+fmax);
				
			}else{
				
				validatorUtil(id);
			}
			
		}else if(regFloat.test(js)){
			console.log("float");
			 if(hjs<fmin||hjs>fmax){
				
				validatorUtil(id,"基数范围"+fmin+"~"+fmax);
				
			}else{
				
				validatorUtil(id);
			}
				 
			
		}else if(!regInt.test(js)&&!regFloat.test(js)){
			console.log("not int , not float");
			 
			
		}else{
			
			validatorUtil(id);
			
		}
		 
	});
});

/*用正则进行分割*/
function regExpSplit(){

   var pattern=/[^\,]/;//以不是,的每个字母进行分割，除了逗号，字母都是分隔符  正则模式也可以用/[^,]/ 不知道为啥要加上个\  逗号又不需要进行转义......
   var colorText="red,blue,green,yellow";
   var colors=colorText.split(pattern);//===,====,=====,======
   $("#split").html(colors.join("="));
   console.log(colors.length);//19
   console.log(pattern.test(colorText));//true
}

function regTest(th){
  
  var reg=/<.*?>/g;//加上?后是非贪婪模式，可以匹配<h1>和</h1>  不加?是贪婪模式，会匹配所有的带有<>的字符串
  var str="<h1>hello world</h1>";
  var rlt=str.replace(reg,"A");//Ahello worldA
  console.log(rlt);
  
  /*为什么和书上说的结果不一样呢? 正则字面量与正则实例是不一样的，正则字面量是共享的，而实例每次都不同，bug....下面的循环却都是true*/
  var str="catastrcathe";
  var re=null;
  for(var i=0;i<5;i++){
      re=/cat/g;
	   console.log( re.lastIndex);
      console.log(re.test("catastroate"));//都是true哎
	   console.log( re.lastIndex);
	// console.log(str.replace(re,"A"));
  }
  console.log("-----------------------------------------------------------");
  for(var i=0;i<5;i++){
     re=new RegExp("cat","g");
	  console.log( re.lastIndex);
     console.log(re.test("catastrophe"));
	   console.log( re.lastIndex);
  }
  
  
}

/*正则的exec()方法，返回数组的第一个元素为匹配的子字符串，第二个为捕获组的结果，也就是()里匹配的一个整体，如果()里不是简单的字符，是元字符，还要根据具体的正则规则确定该元素， result1[1]的结果是o，是正则(\w)+\b匹配的结果*/
function regTest1(th){
  var testString = 'Hello World',
	reg1 = /\b(\w)+\b/;

  var result1 = reg1.exec(testString);
  var first=result1[0];//hello
  var second=result1[1];//o  
  
  console.log(result1);//[hello, o]
  console.log(reg1.lastIndex); //0
  console.log(result1.index); //0 

    
  
}

function regTest2(th){
  var testString = 'Hello World',
	reg = /\b(\w)+\b/g;
  var myAry;
  while((myAry=reg.exec(testString))!=null){
	   console.log(myAry); 
	   console.log(reg.lastIndex);  
	   console.log(myAry.index); 
  }

    
  
}
</script>
</head>

<body>
<input type="button" id="reg1" value="测试标志"/><br />
<p>浮点型和整型正则</p>

<input type="text" id="intFloat" data-min="1000" data-max="2000"/><br />

<p>----------------------------------------------测试用正则作为split的方法参数----------------------------------------</p>
<span id="split"></span>
<br />

<input type="button" id="intFloat"  value="测试用正则分割" onclick="regExpSplit()"/><br />


<input type="button"    value="正则匹配测试"   onclick="regTest(this)"/><br />


<input type="button"    value="模式匹配方法exec()，非全局的"   onclick="regTest1(this)"/><br />

 
 <input type="button"    value="模式匹配方法exec()，全局的"   onclick="regTest2(this)"/>
 
</body>
</html>
